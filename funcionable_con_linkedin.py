# -*- coding: utf-8 -*-
"""funcionable con linkedin

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/178oke1-Pvy2p60-sSDtxn4UKGUgrNPm8
"""

import requests
from bs4 import BeautifulSoup
import time
import re
import random
import json
import os
from datetime import datetime
import hashlib

# CONFIGURACI√ìN JWT PARA PRACTICE
JWT_CONFIG = {
    'login_url': 'http://practicas.fi.ubiobio.cl/index.php/wp-json/jwt-auth/v1/token',
    'posts_url': 'http://practicas.fi.ubiobio.cl/index.php/wp-json/wp/v2/practice',
    'validate_url': 'http://practicas.fi.ubiobio.cl/index.php/wp-json/jwt-auth/v1/token/validate',
    'media_url': 'http://practicas.fi.ubiobio.cl/index.php/wp-json/wp/v2/media',
    'username': 'darkazz123',
    'password': 'RfFroY3E55qd6Dxdcq$R1$qR'
}

# URL de la b√∫squeda en LinkedIn
url = "https://www.linkedin.com/jobs/search/?f_JT=I&f_TPR=r2592000&geoId=104621616&keywords=practica&origin=JOB_SEARCH_PAGE_SEARCH_BUTTON&refresh=true&sortBy=DD&spellCorrectionEnabled=true"

# Encabezados HTTP
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Accept-Language': 'es-ES,es;q=0.9,en;q=0.8',
    'Accept-Encoding': 'gzip, deflate, br',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image:apng,*/*;q=0.8',
    'Connection': 'keep-alive',
}

# Lista de palabras clave para identificar que es una "pr√°ctica"
PALABRAS_CLAVE_PRACTICA = ['pr√°ctica profesional', 'practicante', 'internship', 'pasant√≠a', 'estudiante en pr√°ctica', 'alumnos en pr√°ctica']

# LISTADO DE CARRERAS CON ALIAS M√öLTIPLES
CARRERAS_ALIAS = {
    'Ingenier√≠a Civil Industrial': ['ingenieria civil industrial', 'ing. civil industrial', 'ing civil industrial', 'ingeniero civil industrial', 'civil industrial'],
    'Ingenier√≠a Civil Mec√°nica': ['ingenieria civil mecanica', 'ing. civil mecanica', 'ing civil mecanica', 'ingeniero civil mecanico', 'civil mecanica'],
    'Ingenier√≠a Mec√°nica': ['ingenieria mecanica', 'ing. mecanica', 'ing mecanica', 'ingeniero mecanico'],
    'Ingenier√≠a Civil El√©ctrica': ['ingenieria civil electrica', 'ing. civil electrica', 'ing civil electrica', 'ingeniero civil electrico', 'civil electrico', 'civil electrica'],
    'Ingenier√≠a El√©ctrica': ['ingenieria electrica', 'ing. electrica', 'ing electrica', 'ingeniero electrico'],
    'Ingenier√≠a Electr√≥nica': ['ingenieria electronica', 'ing. electronica', 'ing electronica', 'ingeniero electronico'],
    'Ingenier√≠a Civil en Automatizaci√≥n': ['ingenieria civil en automatizacion', 'ing. civil en automatizacion', 'ingeniero civil en automatizacion', 'civil en automatizacion'],
    'Ingenier√≠a Civil Qu√≠mica': ['ingenieria civil quimica', 'ing. civil quimica', 'ing civil quimica', 'ingeniero civil quimico', 'civil quimico', 'civil quimica'],
    'Ingenier√≠a Civil': ['ingenieria civil', 'ing. civil', 'ing civil', 'ingeniero civil']
}

def generar_hash_oferta(oferta):
    """Genera un hash simple basado en el t√≠tulo y la empresa"""
    base_string = f"{oferta['titulo'].lower()}_{oferta['empresa'].lower()}"
    return hashlib.md5(base_string.encode()).hexdigest()

def cargar_ofertas_publicadas():
    """Carga ofertas ya publicadas desde archivo JSON"""
    try:
        if os.path.exists('ofertas_publicadas.json'):
            with open('ofertas_publicadas.json', 'r', encoding='utf-8') as f:
                return json.load(f)
        return []
    except:
        return []

def guardar_ofertas_publicadas(ofertas_publicadas):
    """Guarda ofertas publicadas en archivo JSON"""
    try:
        with open('ofertas_publicadas.json', 'w', encoding='utf-8') as f:
            json.dump(ofertas_publicadas, f, ensure_ascii=False, indent=2)
    except:
        pass

def limpiar_texto(texto):
    """Limpia el texto de caracteres especiales y normaliza"""
    if not texto:
        return ""

    texto = texto.lower()
    texto = texto.replace('√°', 'a').replace('√©', 'e').replace('√≠', 'i').replace('√≥', 'o').replace('√∫', 'u')
    texto = texto.replace('√±', 'n')
    texto = re.sub(r'[.,]', '', texto)
    texto = re.sub(r'\s+', ' ', texto)
    return texto.strip()

def limpiar_descripcion(descripcion):
    """Limpia la descripci√≥n eliminando 'Show more', 'Show less', etc."""
    if not descripcion:
        return ""

    patrones_eliminar = [
        r'show more\s*show less',
        r'show more',
        r'show less',
        r'ver m√°s\s*ver menos',
        r'ver m√°s',
        r'ver menos'
    ]

    descripcion_limpia = descripcion
    for patron in patrones_eliminar:
        descripcion_limpia = re.sub(patron, '', descripcion_limpia, flags=re.IGNORECASE)

    return re.sub(r'\s+', ' ', descripcion_limpia).strip()

def identificar_carreras_por_alias(titulo, descripcion, carreras_alias_dict):
    """Identifica carreras presentes en el t√≠tulo o descripci√≥n"""
    texto_busqueda = limpiar_texto(titulo + " " + descripcion)

    es_practica = any(keyword in texto_busqueda for keyword in PALABRAS_CLAVE_PRACTICA)
    if not es_practica:
        return []

    carreras_encontradas = set()

    for carrera_oficial, aliases in carreras_alias_dict.items():
        for alias in aliases:
            if alias in texto_busqueda:
                carreras_encontradas.add(carrera_oficial)
                break

    return sorted(list(carreras_encontradas))

def obtener_html(url, headers):
    """Obtiene el HTML de la p√°gina"""
    try:
        session = requests.Session()
        session.headers.update(headers)
        response = session.get(url, timeout=15)
        response.raise_for_status()
        return response.content
    except:
        return None

def extraer_ofertas(html):
    """Extrae las ofertas del HTML"""
    try:
        soup = BeautifulSoup(html, 'html.parser')
        job_listings = soup.find_all('div', class_='base-card relative w-full hover:no-underline focus:no-underline base-card--link base-search-card base-search-card--link job-search-card')
        return job_listings
    except:
        return []

def extraer_descripcion_completa(job_soup):
    """Extrae la descripci√≥n completa y la limpia"""
    selectores = ['.jobs-description__content', '#job-details', '.jobs-box__html-content', '.description__text--rich']

    for selector in selectores:
        elemento = job_soup.select_one(selector)
        if elemento:
            descripcion_raw = elemento.get_text(separator=' ', strip=True)
            return limpiar_descripcion(descripcion_raw)

    return "No se pudo extraer la descripci√≥n."

def extraer_area_de_descripcion(descripcion):
    """Intenta extraer el √°rea de trabajo de la descripci√≥n"""
    areas_comunes = [
        'tecnolog√≠a', 'marketing', 'ventas', 'recursos humanos', 'finanzas',
        'operaciones', 'log√≠stica', 'administraci√≥n', 'ingenier√≠a', 'desarrollo',
        'sistemas', 'inform√°tica', 'contabilidad', 'legal', 'comunicaciones'
    ]

    descripcion_lower = descripcion.lower()
    for area in areas_comunes:
        if area in descripcion_lower:
            return area.title()

    return "No especificada"

def extraer_modalidad_de_descripcion(descripcion):
    """Intenta extraer la modalidad de trabajo de la descripci√≥n"""
    modalidades = {
        'remoto': ['remoto', 'remote', 'teletrabajo', 'home office'],
        'presencial': ['presencial', 'oficina', 'in-site'],
        'h√≠brido': ['h√≠brido', 'hybrid', 'mixto']
    }

    descripcion_lower = descripcion.lower()
    for modalidad, keywords in modalidades.items():
        if any(keyword in descripcion_lower for keyword in keywords):
            return modalidad.title()

    return "No especificada"

def extraer_detalles_oferta(job_listing, carreras_alias_dict, session):
    """Extrae los detalles espec√≠ficos para WordPress"""
    try:
        # Extraer t√≠tulo
        title_element = job_listing.find('h3', class_='base-search-card__title')
        titulo = title_element.text.strip() if title_element else ''

        # Extraer empresa
        company_element = job_listing.find('h4', class_='base-search-card__subtitle')
        empresa = company_element.text.strip() if company_element else ''

        # Extraer ubicaci√≥n
        location_element = job_listing.find('span', class_='job-search-card__location')
        ubicacion = location_element.text.strip() if location_element else ''

        # Extraer fecha
        date_element = job_listing.find('time', class_='job-search-card__listdate')
        fecha_publicacion = date_element['datetime'] if date_element else ''

        # Extraer enlace
        link_element = job_listing.find('a', class_='base-card__full-link')
        link = link_element['href'] if link_element else ''

        # Extraer imagen de la empresa
        imagen_empresa = ''
        img_element = job_listing.find('img', class_='artdeco-entity-image')
        if not img_element:
            img_element = job_listing.find('img', class_='base-card__image')
        if img_element:
            imagen_empresa = img_element.get('data-delayed-url') or img_element.get('src', '')

        # Extraer descripci√≥n
        descripcion = ''
        if link:
            try:
                job_response = session.get(link, timeout=15)
                if job_response.status_code == 200:
                    job_soup = BeautifulSoup(job_response.content, 'html.parser')
                    descripcion = extraer_descripcion_completa(job_soup)
                time.sleep(random.uniform(2, 4))
            except:
                descripcion = "No se pudo extraer la descripci√≥n."

        # Identificar carreras
        carreras_relacionadas = identificar_carreras_por_alias(titulo, descripcion, carreras_alias_dict)

        # Solo devolver si tiene carreras
        if carreras_relacionadas:
            # Extraer informaci√≥n adicional de la descripci√≥n
            area = extraer_area_de_descripcion(descripcion)
            modalidad = extraer_modalidad_de_descripcion(descripcion)

            # Fechas de postulaci√≥n simplificadas
            fecha_actual = datetime.now()
            inicio_postulacion = fecha_actual.strftime('%d/%m/%Y')

            return {
                'fecha_publicacion': fecha_publicacion,
                'titulo': titulo,
                'empresa': empresa,
                'rese√±a_empresa': f"Empresa con presencia en el mercado que ofrece oportunidades de crecimiento profesional.",
                'carreras_relacionadas': carreras_relacionadas,
                'descripcion': descripcion,
                'area': area,
                'beneficios': "Experiencia profesional, desarrollo de habilidades, networking, posible contrataci√≥n posterior",
                'modalidad': modalidad,
                'ubicacion': ubicacion,
                'inicio_postulacion': inicio_postulacion,
                'cierre_postulacion': "Se desconoce fecha cierre",
                'correo_electronico': "Consultar en la oferta original",
                'link': link,
                'observacion': "Postulaci√≥n a trav√©s de LinkedIn. Revisar requisitos espec√≠ficos en la oferta original.",
                'imagen_empresa': imagen_empresa
            }
        return None
    except:
        return None

def obtener_token_jwt():
    """Obtiene token JWT para autenticaci√≥n"""
    credentials = {
        "username": JWT_CONFIG['username'],
        "password": JWT_CONFIG['password']
    }

    try:
        response = requests.post(JWT_CONFIG['login_url'], json=credentials, timeout=10)

        if response.status_code == 200:
            token_data = response.json()
            print(f"‚úÖ Token JWT obtenido exitosamente")
            return token_data['token']
        else:
            print(f"‚ùå Error obteniendo token: {response.status_code}")
            return None

    except:
        print(f"‚ùå Error de conexi√≥n obteniendo token")
        return None

def validar_token_jwt(token):
    """Valida si el token JWT sigue siendo v√°lido"""
    headers = {
        'Authorization': f'Bearer {token}'
    }

    try:
        response = requests.post(JWT_CONFIG['validate_url'], headers=headers, timeout=10)
        return response.status_code == 200
    except:
        return False

def subir_imagen_como_featured_media(token, imagen_url, nombre_empresa):
    """Sube una imagen y la devuelve como ID para featured_media"""
    try:
        if not imagen_url:
            return 0

        print(f"üì§ Subiendo imagen para {nombre_empresa}...")

        # Descargar la imagen
        img_response = requests.get(imagen_url, timeout=15)
        if img_response.status_code != 200:
            print(f"‚ùå No se pudo descargar la imagen")
            return 0

        # Preparar la imagen para subir
        files = {
            'file': (f"{nombre_empresa.replace(' ', '_')}.jpg", img_response.content, 'image/jpeg')
        }

        headers = {
            'Authorization': f'Bearer {token}'
        }

        # Subir a WordPress
        response = requests.post(
            JWT_CONFIG['media_url'],
            files=files,
            headers=headers,
            timeout=30
        )

        if response.status_code == 201:
            media_info = response.json()
            print(f"‚úÖ Imagen subida exitosamente (ID: {media_info['id']})")
            return media_info['id']
        else:
            print(f"‚ö†Ô∏è No se pudo subir imagen: {response.status_code}")
            return 0

    except Exception as e:
        print(f"‚ö†Ô∏è Error subiendo imagen: {e}")
        return 0

def publicar_practica_wordpress_jwt(token, oferta_data):
    """Publica pr√°ctica con imagen destacada"""
    try:
        # 1. SUBIR LA IMAGEN COMO FEATURED MEDIA (si existe)
        featured_media_id = 0
        if oferta_data.get('imagen_empresa'):
            featured_media_id = subir_imagen_como_featured_media(token, oferta_data['imagen_empresa'], oferta_data['empresa'])

        # 2. CREAR EXCERPT PERSONALIZADO para el listado
        carreras_texto = ', '.join(oferta_data['carreras_relacionadas'])
        excerpt_personalizado = f"Pr√°ctica profesional en {oferta_data['empresa']} - {oferta_data['ubicacion']}\nCarrera(s): {carreras_texto}"

        # 3. CREAR SOLO LA TABLA para el contenido
        contenido_html = f"""
        <table class="table table-striped table-responsive">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Detalle</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Empresa</td>
                    <td>{oferta_data['empresa']}</td>
                </tr>
                <tr>
                    <td>Rese√±a empresa</td>
                    <td>{oferta_data['rese√±a_empresa']}</td>
                </tr>
                <tr>
                    <td>Carrera(s)</td>
                    <td>{', '.join(oferta_data['carreras_relacionadas'])}</td>
                </tr>
                <tr>
                    <td>Descripci√≥n/Funciones</td>
                    <td>{oferta_data['descripcion']}</td>
                </tr>
                <tr>
                    <td>√Årea</td>
                    <td>{oferta_data['area']}</td>
                </tr>
                <tr>
                    <td>Beneficios</td>
                    <td>{oferta_data['beneficios']}</td>
                </tr>
                <tr>
                    <td>Modalidad</td>
                    <td>{oferta_data['modalidad']}</td>
                </tr>
                <tr>
                    <td>Ubicaci√≥n</td>
                    <td>{oferta_data['ubicacion']}</td>
                </tr>
                <tr>
                    <td>Inicio postulaci√≥n</td>
                    <td>{oferta_data['inicio_postulacion']}</td>
                </tr>
                <tr>
                    <td>Cierre postulaci√≥n</td>
                    <td>{oferta_data['cierre_postulacion']}</td>
                </tr>
                <tr>
                    <td>Correo electr√≥nico</td>
                    <td>{oferta_data['correo_electronico']}</td>
                </tr>
                <tr>
                    <td>Link Postulaci√≥n</td>
                    <td><a href="{oferta_data['link']}" target="_blank" rel="noopener">Postular aqu√≠</a></td>
                </tr>
                <tr>
                    <td>Observaci√≥n de la postulaci√≥n</td>
                    <td>{oferta_data['observacion']}</td>
                </tr>
            </tbody>
        </table>
        """

        # 4. DATOS DEL POST (sin taxonom√≠as)
        post_data = {
            "title": oferta_data['titulo'],
            "content": contenido_html,
            "status": "publish",
            "excerpt": excerpt_personalizado,
            "featured_media": featured_media_id,
            "categories": [1]
        }

        # Headers con token JWT
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {token}'
        }

        # Hacer la solicitud POST
        response = requests.post(JWT_CONFIG['posts_url'], json=post_data, headers=headers, timeout=30)

        if response.status_code == 201:
            post_info = response.json()
            print(f"‚úÖ Publicado: {oferta_data['titulo']} (ID: {post_info['id']})")
            print(f"   üñºÔ∏è Imagen: {'S√≠' if featured_media_id else 'No'}")
            print(f"   üéì Carreras: {carreras_texto}")
            return post_info['id']
        else:
            print(f"‚ùå Error JWT: {response.status_code} - {response.text}")
            return None

    except Exception as e:
        print(f"‚ùå Error al publicar: {e}")
        return None

def generar_hash_oferta(oferta):
    """Genera un hash simple basado en el t√≠tulo y la empresa"""
    base_string = f"{oferta['titulo'].lower()}_{oferta['empresa'].lower()}"
    hash_generado = hashlib.md5(base_string.encode()).hexdigest()
    print(f"üîç DEBUG Hash generado: {hash_generado} para '{oferta['titulo']}' - '{oferta['empresa']}'")
    return hash_generado

def verificar_duplicado_publicado(nueva_oferta, ofertas_publicadas):
    """Verifica si una oferta ya fue publicada anteriormente usando hash"""
    if not nueva_oferta or not ofertas_publicadas:
        return False

    # Generar hash para la nueva oferta
    hash_nueva_oferta = generar_hash_oferta(nueva_oferta)
    print(f"üîç DEBUG Verificando duplicado para hash: {hash_nueva_oferta}")

    # Verificar si el hash ya existe en las ofertas publicadas
    for i, oferta_pub in enumerate(ofertas_publicadas):
        # Si la oferta publicada tiene hash, usarlo; si no, generarlo
        if 'hash' in oferta_pub:
            hash_publicado = oferta_pub['hash']
            print(f"üìã DEBUG Hash del JSON [{i}]: {hash_publicado} - '{oferta_pub.get('titulo', 'N/A')}' - '{oferta_pub.get('empresa', 'N/A')}'")
        else:
            hash_publicado = generar_hash_oferta(oferta_pub)
            print(f"üìã DEBUG Hash generado del JSON [{i}]: {hash_publicado} - '{oferta_pub.get('titulo', 'N/A')}' - '{oferta_pub.get('empresa', 'N/A')}'")

        if hash_publicado == hash_nueva_oferta:
            print(f"üîÑ DEBUG ¬°DUPLICADO ENCONTRADO! Hash coincide: {hash_nueva_oferta}")
            return True

    print(f"‚úÖ DEBUG No se encontr√≥ duplicado para: {hash_nueva_oferta}")
    return False

def verificar_duplicado_en_jobs(nueva_oferta, jobs_existentes):
    """Verifica si una oferta ya existe en la lista de trabajos actual usando hash"""
    if not nueva_oferta or not jobs_existentes:
        return False

    # Generar hash para la nueva oferta
    hash_nueva_oferta = generar_hash_oferta(nueva_oferta)
    print(f"üîç DEBUG Verificando duplicado en sesi√≥n para hash: {hash_nueva_oferta}")

    # Verificar si el hash ya existe en la lista de hashes de ofertas existentes
    for i, job in enumerate(jobs_existentes):
        hash_existente = generar_hash_oferta(job)
        print(f"üìã DEBUG Hash sesi√≥n [{i}]: {hash_existente}")
        if hash_existente == hash_nueva_oferta:
            print(f"üîÑ DEBUG ¬°DUPLICADO EN SESI√ìN! Hash coincide: {hash_nueva_oferta}")
            return True

    print(f"‚úÖ DEBUG No se encontr√≥ duplicado en sesi√≥n para: {hash_nueva_oferta}")
    return False

def cargar_ofertas_publicadas():
    """Carga ofertas ya publicadas desde archivo JSON"""
    try:
        if os.path.exists('ofertas_publicadas.json'):
            with open('ofertas_publicadas.json', 'r', encoding='utf-8') as f:
                ofertas = json.load(f)
                print(f"üìÅ DEBUG Cargadas {len(ofertas)} ofertas del JSON")

                # Mostrar las primeras 3 ofertas del JSON para debug
                for i, oferta in enumerate(ofertas[:3]):
                    hash_en_json = oferta.get('hash', 'NO_HASH')
                    titulo = oferta.get('titulo', 'NO_TITULO')
                    empresa = oferta.get('empresa', 'NO_EMPRESA')
                    print(f"üìã DEBUG JSON [{i}]: Hash={hash_en_json}, T√≠tulo='{titulo}', Empresa='{empresa}'")

                return ofertas
        else:
            print("üìÅ DEBUG No existe archivo JSON, creando lista vac√≠a")
        return []
    except Exception as e:
        print(f"‚ùå DEBUG Error cargando JSON: {e}")
        return []

def main():
    """Funci√≥n principal con JWT Authentication y sistema de hash con debug"""
    print("üöÄ Iniciando proceso automatizado LinkedIn ‚Üí WordPress con JWT...")

    # Obtener token JWT
    token = obtener_token_jwt()
    if not token:
        print("‚ùå No se pudo obtener token JWT")
        return

    # Cargar ofertas ya publicadas
    ofertas_publicadas = cargar_ofertas_publicadas()
    print(f"üìö Cargadas {len(ofertas_publicadas)} ofertas previamente publicadas")

    # Scraping de LinkedIn
    html = obtener_html(url, headers)
    if not html:
        print("‚ùå No se pudo obtener el HTML de LinkedIn")
        return

    job_listings = extraer_ofertas(html)
    if not job_listings:
        print("‚ùå No se encontraron ofertas de trabajo")
        return

    print(f"üîç Encontradas {len(job_listings)} ofertas en LinkedIn")

    jobs_wordpress = []
    jobs_procesados_session = []
    session = requests.Session()
    session.headers.update(headers)

    # Extraer detalles de cada oferta
    for i, job_listing in enumerate(job_listings, 1):
        print(f"\n{'='*60}")
        print(f"Procesando oferta {i}/{len(job_listings)}")

        job = extraer_detalles_oferta(job_listing, CARRERAS_ALIAS, session)
        if job:
            print(f"üìù DEBUG Oferta extra√≠da: '{job['titulo']}' - '{job['empresa']}'")

            # Verificar duplicados en la sesi√≥n actual
            print(f"\nüîç DEBUG Verificando duplicados en sesi√≥n actual...")
            if not verificar_duplicado_en_jobs(job, jobs_procesados_session):
                jobs_wordpress.append(job)
                jobs_procesados_session.append(job)
                print(f"  ‚úÖ Oferta agregada: {job['titulo']}")
            else:
                print(f"  üîÑ Oferta duplicada en esta sesi√≥n: {job['titulo']}")
        else:
            print(f"‚ùå DEBUG No se pudo extraer la oferta {i}")

    if not jobs_wordpress:
        print("‚ùå No se encontraron ofertas relevantes")
        return

    print(f"\nüìã {len(jobs_wordpress)} ofertas √∫nicas encontradas")

    # Publicar en WordPress usando JWT
    publicadas = 0
    duplicadas = 0
    errores = 0

    for oferta in jobs_wordpress:
        print(f"\n{'='*60}")
        print(f"üîç DEBUG Verificando si ya fue publicada: '{oferta['titulo']}' - '{oferta['empresa']}'")

        # Verificar duplicados con ofertas previamente publicadas usando hash
        if verificar_duplicado_publicado(oferta, ofertas_publicadas):
            duplicadas += 1
            print(f"  üîÑ Ya publicada anteriormente: {oferta['titulo']}")
            continue

        # Validar token antes de cada publicaci√≥n
        if not validar_token_jwt(token):
            print("‚ö†Ô∏è Token expirado, obteniendo nuevo token...")
            token = obtener_token_jwt()
            if not token:
                print("‚ùå No se pudo renovar el token")
                break

        # Publicar usando JWT
        print(f"üì§ Publicando: {oferta['titulo']}")
        post_id = publicar_practica_wordpress_jwt(token, oferta)

        if post_id:
            # Generar hash para la oferta publicada
            hash_oferta = generar_hash_oferta(oferta)
            print(f"üíæ DEBUG Guardando en JSON con hash: {hash_oferta}")

            ofertas_publicadas.append({
                'hash': hash_oferta,
                'titulo': oferta['titulo'],
                'empresa': oferta['empresa'],
                'fecha_publicacion': oferta['fecha_publicacion'],
                'fecha_procesamiento': datetime.now().isoformat(),
                'post_id': post_id
            })
            publicadas += 1
        else:
            errores += 1
            print(f"  ‚ùå Error publicando: {oferta['titulo']}")

        # Pausa entre publicaciones
        time.sleep(random.uniform(2, 4))

    # Guardar lista actualizada
    guardar_ofertas_publicadas(ofertas_publicadas)

    # Resumen final
    print(f"\n{'='*50}")
    print(f"üìä RESUMEN FINAL:")
    print(f"{'='*50}")
    print(f"   üÜï Ofertas nuevas publicadas: {publicadas}")
    print(f"   üîÑ Ofertas duplicadas omitidas: {duplicadas}")
    print(f"   ‚ùå Errores en publicaci√≥n: {errores}")
    print(f"   üìà Total ofertas procesadas: {len(jobs_wordpress)}")
    print(f"   üíæ Total ofertas en historial: {len(ofertas_publicadas)}")

    # Estad√≠sticas por carrera
    if jobs_wordpress:
        carreras_count = {}
        for job in jobs_wordpress:
            for carrera in job['carreras_relacionadas']:
                carreras_count[carrera] = carreras_count.get(carrera, 0) + 1

        print(f"\nüìà CARRERAS ENCONTRADAS:")
        for carrera, count in sorted(carreras_count.items()):
            print(f"   üéì {carrera}: {count} ofertas")

    print(f"\n‚è∞ Pr√≥xima ejecuci√≥n recomendada: En 7 d√≠as")

# Ejecutar el programa
if __name__ == "__main__":
    main()

import requests
from bs4 import BeautifulSoup
import time
import re
import random
import json
import os
from datetime import datetime
import hashlib

# CONFIGURACI√ìN JWT PARA PRACTICE
JWT_CONFIG = {
    'login_url': 'http://practicas.fi.ubiobio.cl/index.php/wp-json/jwt-auth/v1/token',
    'posts_url': 'http://practicas.fi.ubiobio.cl/index.php/wp-json/wp/v2/practice',
    'validate_url': 'http://practicas.fi.ubiobio.cl/index.php/wp-json/jwt-auth/v1/token/validate',
    'media_url': 'http://practicas.fi.ubiobio.cl/index.php/wp-json/wp/v2/media',
    'username': 'darkazz123',
    'password': 'RfFroY3E55qd6Dxdcq$R1$qR'
}

# URL de la b√∫squeda en LinkedIn
url = "https://www.linkedin.com/jobs/search/?f_JT=I&f_TPR=r2592000&geoId=104621616&keywords=practica&origin=JOB_SEARCH_PAGE_SEARCH_BUTTON&refresh=true&sortBy=DD&spellCorrectionEnabled=true"

# Encabezados HTTP
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Accept-Language': 'es-ES,es;q=0.9,en;q=0.8',
    'Accept-Encoding': 'gzip, deflate, br',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image:apng,*/*;q=0.8',
    'Connection': 'keep-alive',
}

# Lista de palabras clave para identificar que es una "pr√°ctica"
PALABRAS_CLAVE_PRACTICA = ['pr√°ctica profesional', 'practicante', 'internship', 'pasant√≠a', 'estudiante en pr√°ctica', 'alumnos en pr√°ctica']

# falta agregar ing ejecicion electricidad
# LISTADO DE CARRERAS CON ALIAS M√öLTIPLES
CARRERAS_ALIAS = {
    'Ingenier√≠a Civil Industrial': ['ingenieria civil industrial', 'ing. civil industrial', 'ing civil industrial', 'ingeniero civil industrial', 'civil industrial'],
    'Ingenier√≠a Ejecucion en Mec√°nica': ['ingenieria ejecucion mecanica', 'ing. ejecucion mecanica', 'ing ejecucion mecanica', 'ingeniero ejecucion mecanico', 'ejecucion mecanica'],
    'Ingenier√≠a Civil El√©ctrica': ['ingenieria civil electrica', 'ing. civil electrica', 'ing civil electrica', 'ingeniero civil electrico', 'civil electrico', 'civil electrica'],
    'Ingenier√≠a Civil en Automatizaci√≥n': ['ingenieria civil en automatizacion', 'ing. civil en automatizacion', 'ingeniero civil en automatizacion', 'civil en automatizacion'],
    'Ingenier√≠a Civil Qu√≠mica': ['ingenieria civil quimica', 'ing. civil quimica', 'ing civil quimica', 'ingeniero civil quimico', 'civil quimico', 'civil quimica'],
    'Ingenier√≠a Civil': ['ingenieria civil', 'ing. civil', 'ing civil', 'ingeniero civil']
}

def generar_hash_oferta(oferta):
    """Genera un hash simple basado en el t√≠tulo y la empresa"""
    base_string = f"{oferta['titulo'].lower()}_{oferta['empresa'].lower()}"
    return hashlib.md5(base_string.encode()).hexdigest()

def cargar_ofertas_publicadas():
    """Carga ofertas ya publicadas desde archivo JSON"""
    try:
        if os.path.exists('ofertas_publicadas.json'):
            with open('ofertas_publicadas.json', 'r', encoding='utf-8') as f:
                return json.load(f)
        return []
    except:
        return []

def guardar_ofertas_publicadas(ofertas_publicadas):
    """Guarda ofertas publicadas en archivo JSON"""
    try:
        with open('ofertas_publicadas.json', 'w', encoding='utf-8') as f:
            json.dump(ofertas_publicadas, f, ensure_ascii=False, indent=2)
    except:
        pass

def limpiar_texto(texto):
    """Limpia el texto de caracteres especiales y normaliza"""
    if not texto:
        return ""

    texto = texto.lower()
    texto = texto.replace('√°', 'a').replace('√©', 'e').replace('√≠', 'i').replace('√≥', 'o').replace('√∫', 'u')
    texto = texto.replace('√±', 'n')
    texto = re.sub(r'[.,]', '', texto)
    texto = re.sub(r'\s+', ' ', texto)
    return texto.strip()

def limpiar_descripcion(descripcion):
    """Limpia la descripci√≥n eliminando 'Show more', 'Show less', etc."""
    if not descripcion:
        return ""

    patrones_eliminar = [
        r'show more\s*show less',
        r'show more',
        r'show less',
        r'ver m√°s\s*ver menos',
        r'ver m√°s',
        r'ver menos'
    ]

    descripcion_limpia = descripcion
    for patron in patrones_eliminar:
        descripcion_limpia = re.sub(patron, '', descripcion_limpia, flags=re.IGNORECASE)

    return re.sub(r'\s+', ' ', descripcion_limpia).strip()

def identificar_carreras_por_alias(titulo, descripcion, carreras_alias_dict):
    """Identifica carreras presentes en el t√≠tulo o descripci√≥n"""
    texto_busqueda = limpiar_texto(titulo + " " + descripcion)

    es_practica = any(keyword in texto_busqueda for keyword in PALABRAS_CLAVE_PRACTICA)
    if not es_practica:
        return []

    carreras_encontradas = set()

    for carrera_oficial, aliases in carreras_alias_dict.items():
        for alias in aliases:
            if alias in texto_busqueda:
                carreras_encontradas.add(carrera_oficial)
                break

    return sorted(list(carreras_encontradas))

def obtener_html(url, headers):
    """Obtiene el HTML de la p√°gina"""
    try:
        session = requests.Session()
        session.headers.update(headers)
        response = session.get(url, timeout=15)
        response.raise_for_status()
        return response.content
    except:
        return None

def extraer_ofertas(html):
    """Extrae las ofertas del HTML"""
    try:
        soup = BeautifulSoup(html, 'html.parser')
        job_listings = soup.find_all('div', class_='base-card relative w-full hover:no-underline focus:no-underline base-card--link base-search-card base-search-card--link job-search-card')
        return job_listings
    except:
        return []

def extraer_descripcion_completa(job_soup):
    """Extrae la descripci√≥n completa y la limpia"""
    selectores = ['.jobs-description__content', '#job-details', '.jobs-box__html-content', '.description__text--rich']

    for selector in selectores:
        elemento = job_soup.select_one(selector)
        if elemento:
            descripcion_raw = elemento.get_text(separator=' ', strip=True)
            return limpiar_descripcion(descripcion_raw)

    return "No se pudo extraer la descripci√≥n."

def extraer_area_de_descripcion(descripcion):
    """Intenta extraer el √°rea de trabajo de la descripci√≥n"""
    areas_comunes = [
        'tecnolog√≠a', 'marketing', 'ventas', 'recursos humanos', 'finanzas',
        'operaciones', 'log√≠stica', 'administraci√≥n', 'ingenier√≠a', 'desarrollo',
        'sistemas', 'inform√°tica', 'contabilidad', 'legal', 'comunicaciones'
    ]

    descripcion_lower = descripcion.lower()
    for area in areas_comunes:
        if area in descripcion_lower:
            return area.title()

    return "No especificada"

def extraer_modalidad_de_descripcion(descripcion):
    """Intenta extraer la modalidad de trabajo de la descripci√≥n"""
    modalidades = {
        'remoto': ['remoto', 'remote', 'teletrabajo', 'home office'],
        'presencial': ['presencial', 'oficina', 'in-site'],
        'h√≠brido': ['h√≠brido', 'hybrid', 'mixto']
    }

    descripcion_lower = descripcion.lower()
    for modalidad, keywords in modalidades.items():
        if any(keyword in descripcion_lower for keyword in keywords):
            return modalidad.title()

    return "No especificada"

def extraer_detalles_oferta(job_listing, carreras_alias_dict, session):
    """Extrae los detalles espec√≠ficos para WordPress"""
    try:
        # Extraer t√≠tulo
        title_element = job_listing.find('h3', class_='base-search-card__title')
        titulo = title_element.text.strip() if title_element else ''

        # Extraer empresa
        company_element = job_listing.find('h4', class_='base-search-card__subtitle')
        empresa = company_element.text.strip() if company_element else ''

        # Extraer ubicaci√≥n
        location_element = job_listing.find('span', class_='job-search-card__location')
        ubicacion = location_element.text.strip() if location_element else ''

        # Extraer fecha
        date_element = job_listing.find('time', class_='job-search-card__listdate')
        fecha_publicacion = date_element['datetime'] if date_element else ''

        # Extraer enlace
        link_element = job_listing.find('a', class_='base-card__full-link')
        link = link_element['href'] if link_element else ''

        # Extraer imagen de la empresa
        imagen_empresa = ''
        img_element = job_listing.find('img', class_='artdeco-entity-image')
        if not img_element:
            img_element = job_listing.find('img', class_='base-card__image')
        if img_element:
            imagen_empresa = img_element.get('data-delayed-url') or img_element.get('src', '')

        # Extraer descripci√≥n
        descripcion = ''
        if link:
            try:
                job_response = session.get(link, timeout=15)
                if job_response.status_code == 200:
                    job_soup = BeautifulSoup(job_response.content, 'html.parser')
                    descripcion = extraer_descripcion_completa(job_soup)
                time.sleep(random.uniform(2, 4))
            except:
                descripcion = "No se pudo extraer la descripci√≥n."

        # Identificar carreras
        carreras_relacionadas = identificar_carreras_por_alias(titulo, descripcion, carreras_alias_dict)

        # Solo devolver si tiene carreras
        if carreras_relacionadas:
            # Extraer informaci√≥n adicional de la descripci√≥n
            area = extraer_area_de_descripcion(descripcion)
            modalidad = extraer_modalidad_de_descripcion(descripcion)

            # Fechas de postulaci√≥n simplificadas
            fecha_actual = datetime.now()
            inicio_postulacion = fecha_actual.strftime('%d/%m/%Y')

            return {
                'fecha_publicacion': fecha_publicacion,
                'titulo': titulo,
                'empresa': empresa,
                'rese√±a_empresa': f"Empresa con presencia en el mercado que ofrece oportunidades de crecimiento profesional.",
                'carreras_relacionadas': carreras_relacionadas,
                'descripcion': descripcion,
                'area': area,
                'beneficios': "Experiencia profesional, desarrollo de habilidades, networking, posible contrataci√≥n posterior",
                'modalidad': modalidad,
                'ubicacion': ubicacion,
                'inicio_postulacion': inicio_postulacion,
                'cierre_postulacion': "Se desconoce fecha cierre",
                'correo_electronico': "Consultar en la oferta original",
                'link': link,
                'observacion': "Postulaci√≥n a trav√©s de LinkedIn. Revisar requisitos espec√≠ficos en la oferta original.",
                'imagen_empresa': imagen_empresa
            }
        return None
    except:
        return None

def obtener_token_jwt():
    """Obtiene token JWT para autenticaci√≥n"""
    credentials = {
        "username": JWT_CONFIG['username'],
        "password": JWT_CONFIG['password']
    }

    try:
        response = requests.post(JWT_CONFIG['login_url'], json=credentials, timeout=10)

        if response.status_code == 200:
            token_data = response.json()
            print(f"‚úÖ Token JWT obtenido exitosamente")
            return token_data['token']
        else:
            print(f"‚ùå Error obteniendo token: {response.status_code}")
            return None

    except:
        print(f"‚ùå Error de conexi√≥n obteniendo token")
        return None

def validar_token_jwt(token):
    """Valida si el token JWT sigue siendo v√°lido"""
    headers = {
        'Authorization': f'Bearer {token}'
    }

    try:
        response = requests.post(JWT_CONFIG['validate_url'], headers=headers, timeout=10)
        return response.status_code == 200
    except:
        return False

def subir_imagen_como_featured_media(token, imagen_url, nombre_empresa):
    """Sube una imagen y la devuelve como ID para featured_media"""
    try:
        if not imagen_url:
            return 0

        print(f"üì§ Subiendo imagen para {nombre_empresa}...")

        # Descargar la imagen
        img_response = requests.get(imagen_url, timeout=15)
        if img_response.status_code != 200:
            print(f"‚ùå No se pudo descargar la imagen")
            return 0

        # Preparar la imagen para subir
        files = {
            'file': (f"{nombre_empresa.replace(' ', '_')}.jpg", img_response.content, 'image/jpeg')
        }

        headers = {
            'Authorization': f'Bearer {token}'
        }

        # Subir a WordPress
        response = requests.post(
            JWT_CONFIG['media_url'],
            files=files,
            headers=headers,
            timeout=30
        )

        if response.status_code == 201:
            media_info = response.json()
            print(f"‚úÖ Imagen subida exitosamente (ID: {media_info['id']})")
            return media_info['id']
        else:
            print(f"‚ö†Ô∏è No se pudo subir imagen: {response.status_code}")
            return 0

    except Exception as e:
        print(f"‚ö†Ô∏è Error subiendo imagen: {e}")
        return 0

def publicar_practica_wordpress_jwt(token, oferta_data):
    """Publica pr√°ctica con imagen destacada"""
    try:
        # 1. SUBIR LA IMAGEN COMO FEATURED MEDIA (si existe)
        featured_media_id = 0
        if oferta_data.get('imagen_empresa'):
            featured_media_id = subir_imagen_como_featured_media(token, oferta_data['imagen_empresa'], oferta_data['empresa'])

        # 2. CREAR EXCERPT PERSONALIZADO para el listado
        carreras_texto = ', '.join(oferta_data['carreras_relacionadas'])
        excerpt_personalizado = f"Pr√°ctica profesional en {oferta_data['empresa']} - {oferta_data['ubicacion']}\nCarrera(s): {carreras_texto}"

        # 3. CREAR SOLO LA TABLA para el contenido
        contenido_html = f"""
        <table class="table table-striped table-responsive">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Detalle</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Empresa</td>
                    <td>{oferta_data['empresa']}</td>
                </tr>
                <tr>
                    <td>Rese√±a empresa</td>
                    <td>{oferta_data['rese√±a_empresa']}</td>
                </tr>
                <tr>
                    <td>Carrera(s)</td>
                    <td>{', '.join(oferta_data['carreras_relacionadas'])}</td>
                </tr>
                <tr>
                    <td>Descripci√≥n/Funciones</td>
                    <td>{oferta_data['descripcion']}</td>
                </tr>
                <tr>
                    <td>√Årea</td>
                    <td>{oferta_data['area']}</td>
                </tr>
                <tr>
                    <td>Beneficios</td>
                    <td>{oferta_data['beneficios']}</td>
                </tr>
                <tr>
                    <td>Modalidad</td>
                    <td>{oferta_data['modalidad']}</td>
                </tr>
                <tr>
                    <td>Ubicaci√≥n</td>
                    <td>{oferta_data['ubicacion']}</td>
                </tr>
                <tr>
                    <td>Inicio postulaci√≥n</td>
                    <td>{oferta_data['inicio_postulacion']}</td>
                </tr>
                <tr>
                    <td>Cierre postulaci√≥n</td>
                    <td>{oferta_data['cierre_postulacion']}</td>
                </tr>
                <tr>
                    <td>Correo electr√≥nico</td>
                    <td>{oferta_data['correo_electronico']}</td>
                </tr>
                <tr>
                    <td>Link Postulaci√≥n</td>
                    <td><a href="{oferta_data['link']}" target="_blank" rel="noopener">Postular aqu√≠</a></td>
                </tr>
                <tr>
                    <td>Observaci√≥n de la postulaci√≥n</td>
                    <td>{oferta_data['observacion']}</td>
                </tr>
            </tbody>
        </table>
        """

        # 4. DATOS DEL POST (sin taxonom√≠as)
        post_data = {
            "title": oferta_data['titulo'],
            "content": contenido_html,
            "status": "publish",
            "excerpt": excerpt_personalizado,
            "featured_media": featured_media_id,
            "categories": [1]
        }

        # Headers con token JWT
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {token}'
        }

        # Hacer la solicitud POST
        response = requests.post(JWT_CONFIG['posts_url'], json=post_data, headers=headers, timeout=30)

        if response.status_code == 201:
            post_info = response.json()
            print(f"‚úÖ Publicado: {oferta_data['titulo']} (ID: {post_info['id']})")
            print(f"   üñºÔ∏è Imagen: {'S√≠' if featured_media_id else 'No'}")
            print(f"   üéì Carreras: {carreras_texto}")
            return post_info['id']
        else:
            print(f"‚ùå Error JWT: {response.status_code} - {response.text}")
            return None

    except Exception as e:
        print(f"‚ùå Error al publicar: {e}")
        return None

def generar_hash_oferta(oferta):
    """Genera un hash simple basado en el t√≠tulo y la empresa"""
    base_string = f"{oferta['titulo'].lower()}_{oferta['empresa'].lower()}"
    hash_generado = hashlib.md5(base_string.encode()).hexdigest()
    print(f"üîç DEBUG Hash generado: {hash_generado} para '{oferta['titulo']}' - '{oferta['empresa']}'")
    return hash_generado

def verificar_duplicado_publicado(nueva_oferta, ofertas_publicadas):
    """Verifica si una oferta ya fue publicada anteriormente usando hash"""
    if not nueva_oferta or not ofertas_publicadas:
        return False

    # Generar hash para la nueva oferta
    hash_nueva_oferta = generar_hash_oferta(nueva_oferta)
    print(f"üîç DEBUG Verificando duplicado para hash: {hash_nueva_oferta}")

    # Verificar si el hash ya existe en las ofertas publicadas
    for i, oferta_pub in enumerate(ofertas_publicadas):
        # Si la oferta publicada tiene hash, usarlo; si no, generarlo
        if 'hash' in oferta_pub:
            hash_publicado = oferta_pub['hash']
            print(f"üìã DEBUG Hash del JSON [{i}]: {hash_publicado} - '{oferta_pub.get('titulo', 'N/A')}' - '{oferta_pub.get('empresa', 'N/A')}'")
        else:
            hash_publicado = generar_hash_oferta(oferta_pub)
            print(f"üìã DEBUG Hash generado del JSON [{i}]: {hash_publicado} - '{oferta_pub.get('titulo', 'N/A')}' - '{oferta_pub.get('empresa', 'N/A')}'")

        if hash_publicado == hash_nueva_oferta:
            print(f"üîÑ DEBUG ¬°DUPLICADO ENCONTRADO! Hash coincide: {hash_nueva_oferta}")
            return True

    print(f"‚úÖ DEBUG No se encontr√≥ duplicado para: {hash_nueva_oferta}")
    return False

def verificar_duplicado_en_jobs(nueva_oferta, jobs_existentes):
    """Verifica si una oferta ya existe en la lista de trabajos actual usando hash"""
    if not nueva_oferta or not jobs_existentes:
        return False

    # Generar hash para la nueva oferta
    hash_nueva_oferta = generar_hash_oferta(nueva_oferta)
    print(f"üîç DEBUG Verificando duplicado en sesi√≥n para hash: {hash_nueva_oferta}")

    # Verificar si el hash ya existe en la lista de hashes de ofertas existentes
    for i, job in enumerate(jobs_existentes):
        hash_existente = generar_hash_oferta(job)
        print(f"üìã DEBUG Hash sesi√≥n [{i}]: {hash_existente}")
        if hash_existente == hash_nueva_oferta:
            print(f"üîÑ DEBUG ¬°DUPLICADO EN SESI√ìN! Hash coincide: {hash_nueva_oferta}")
            return True

    print(f"‚úÖ DEBUG No se encontr√≥ duplicado en sesi√≥n para: {hash_nueva_oferta}")
    return False

def cargar_ofertas_publicadas():
    """Carga ofertas ya publicadas desde archivo JSON"""
    try:
        if os.path.exists('ofertas_publicadas.json'):
            with open('ofertas_publicadas.json', 'r', encoding='utf-8') as f:
                ofertas = json.load(f)
                print(f"üìÅ DEBUG Cargadas {len(ofertas)} ofertas del JSON")

                # Mostrar las primeras 3 ofertas del JSON para debug
                for i, oferta in enumerate(ofertas[:3]):
                    hash_en_json = oferta.get('hash', 'NO_HASH')
                    titulo = oferta.get('titulo', 'NO_TITULO')
                    empresa = oferta.get('empresa', 'NO_EMPRESA')
                    print(f"üìã DEBUG JSON [{i}]: Hash={hash_en_json}, T√≠tulo='{titulo}', Empresa='{empresa}'")

                return ofertas
        else:
            print("üìÅ DEBUG No existe archivo JSON, creando lista vac√≠a")
        return []
    except Exception as e:
        print(f"‚ùå DEBUG Error cargando JSON: {e}")
        return []

def main():
    """Funci√≥n principal con JWT Authentication y sistema de hash con debug"""
    print("üöÄ Iniciando proceso automatizado LinkedIn ‚Üí WordPress con JWT...")

    # Obtener token JWT
    token = obtener_token_jwt()
    if not token:
        print("‚ùå No se pudo obtener token JWT")
        return

    # Cargar ofertas ya publicadas
    ofertas_publicadas = cargar_ofertas_publicadas()
    print(f"üìö Cargadas {len(ofertas_publicadas)} ofertas previamente publicadas")

    # Scraping de LinkedIn
    html = obtener_html(url, headers)
    if not html:
        print("‚ùå No se pudo obtener el HTML de LinkedIn")
        return

    job_listings = extraer_ofertas(html)
    if not job_listings:
        print("‚ùå No se encontraron ofertas de trabajo")
        return

    print(f"üîç Encontradas {len(job_listings)} ofertas en LinkedIn")

    jobs_wordpress = []
    jobs_procesados_session = []
    session = requests.Session()
    session.headers.update(headers)

    # Extraer detalles de cada oferta
    for i, job_listing in enumerate(job_listings, 1):
        print(f"\n{'='*60}")
        print(f"Procesando oferta {i}/{len(job_listings)}")

        job = extraer_detalles_oferta(job_listing, CARRERAS_ALIAS, session)
        if job:
            print(f"üìù DEBUG Oferta extra√≠da: '{job['titulo']}' - '{job['empresa']}'")

            # Verificar duplicados en la sesi√≥n actual
            print(f"\nüîç DEBUG Verificando duplicados en sesi√≥n actual...")
            if not verificar_duplicado_en_jobs(job, jobs_procesados_session):
                jobs_wordpress.append(job)
                jobs_procesados_session.append(job)
                print(f"  ‚úÖ Oferta agregada: {job['titulo']}")
            else:
                print(f"  üîÑ Oferta duplicada en esta sesi√≥n: {job['titulo']}")
        else:
            print(f"‚ùå DEBUG No se pudo extraer la oferta {i}")

    if not jobs_wordpress:
        print("‚ùå No se encontraron ofertas relevantes")
        return

    print(f"\nüìã {len(jobs_wordpress)} ofertas √∫nicas encontradas")

    # Publicar en WordPress usando JWT
    publicadas = 0
    duplicadas = 0
    errores = 0

    for oferta in jobs_wordpress:
        print(f"\n{'='*60}")
        print(f"üîç DEBUG Verificando si ya fue publicada: '{oferta['titulo']}' - '{oferta['empresa']}'")

        # Verificar duplicados con ofertas previamente publicadas usando hash
        if verificar_duplicado_publicado(oferta, ofertas_publicadas):
            duplicadas += 1
            print(f"  üîÑ Ya publicada anteriormente: {oferta['titulo']}")
            continue

        # Validar token antes de cada publicaci√≥n
        if not validar_token_jwt(token):
            print("‚ö†Ô∏è Token expirado, obteniendo nuevo token...")
            token = obtener_token_jwt()
            if not token:
                print("‚ùå No se pudo renovar el token")
                break

        # Publicar usando JWT
        print(f"üì§ Publicando: {oferta['titulo']}")
        post_id = publicar_practica_wordpress_jwt(token, oferta)

        if post_id:
            # Generar hash para la oferta publicada
            hash_oferta = generar_hash_oferta(oferta)
            print(f"üíæ DEBUG Guardando en JSON con hash: {hash_oferta}")

            ofertas_publicadas.append({
                'hash': hash_oferta,
                'titulo': oferta['titulo'],
                'empresa': oferta['empresa'],
                'fecha_publicacion': oferta['fecha_publicacion'],
                'fecha_procesamiento': datetime.now().isoformat(),
                'post_id': post_id
            })
            publicadas += 1
        else:
            errores += 1
            print(f"  ‚ùå Error publicando: {oferta['titulo']}")

        # Pausa entre publicaciones
        time.sleep(random.uniform(2, 4))

    # Guardar lista actualizada
    guardar_ofertas_publicadas(ofertas_publicadas)

    # Resumen final
    print(f"\n{'='*50}")
    print(f"üìä RESUMEN FINAL:")
    print(f"{'='*50}")
    print(f"   üÜï Ofertas nuevas publicadas: {publicadas}")
    print(f"   üîÑ Ofertas duplicadas omitidas: {duplicadas}")
    print(f"   ‚ùå Errores en publicaci√≥n: {errores}")
    print(f"   üìà Total ofertas procesadas: {len(jobs_wordpress)}")
    print(f"   üíæ Total ofertas en historial: {len(ofertas_publicadas)}")

    # Estad√≠sticas por carrera
    if jobs_wordpress:
        carreras_count = {}
        for job in jobs_wordpress:
            for carrera in job['carreras_relacionadas']:
                carreras_count[carrera] = carreras_count.get(carrera, 0) + 1

        print(f"\nüìà CARRERAS ENCONTRADAS:")
        for carrera, count in sorted(carreras_count.items()):
            print(f"   üéì {carrera}: {count} ofertas")

    print(f"\n‚è∞ Pr√≥xima ejecuci√≥n recomendada: En 7 d√≠as")

# Ejecutar el programa
if __name__ == "__main__":
    main()